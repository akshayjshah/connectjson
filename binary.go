package connectproto

import (
	"fmt"

	"connectrpc.com/connect"
	"google.golang.org/protobuf/proto"
)

// WithBinary customizes a connect-go Client or Handler's binary protobuf
// handling, using any options supported by [google.golang.org/protobuf].
func WithBinary(marshal proto.MarshalOptions, unmarshal proto.UnmarshalOptions) connect.Option {
	return connect.WithCodec(newBinaryCodec(marshal, unmarshal))
}

// WithBinaryVT customizes a connect-go Client or Handler's binary protobuf
// handling, using the optimized marshaling and unmarshaling methods produced
// by [vtprotobuf] where possible. If the methods generated by vtprotobuf
// aren't available, the codec falls back to [google.golang.org/protobuf] with
// the default options.
//
// [vtprotobuf]: https://github.com/planetscale/vtprotobuf
func WithBinaryVT() connect.Option {
	return connect.WithCodec(newBinaryVTCodec())
}

// WithBinaryVTWithFallback customizes a connect-go Client or Handler's binary protobuf
// handling, using the optimized marshaling and unmarshaling methods produced
// by [vtprotobuf] where possible. If the methods generated by vtprotobuf
// aren't available, the codec falls back to [google.golang.org/protobuf] with
// the given options.
//
// [vtprotobuf]: https://github.com/planetscale/vtprotobuf
func WithBinaryVTWithFallback(marshal proto.MarshalOptions, unmarshal proto.UnmarshalOptions) connect.Option {
	return connect.WithCodec(newBinaryVTCodecWithFallback(newBinaryCodec(marshal, unmarshal)))
}

type binaryCodec struct {
	name      string
	marshal   proto.MarshalOptions
	stable    proto.MarshalOptions
	unmarshal proto.UnmarshalOptions
}

func newBinaryCodec(marshal proto.MarshalOptions, unmarshal proto.UnmarshalOptions) *binaryCodec {
	stable := marshal
	stable.Deterministic = true
	return &binaryCodec{
		name:      "proto",
		marshal:   marshal,
		stable:    stable,
		unmarshal: unmarshal,
	}
}

func (b *binaryCodec) Name() string { return b.name }

func (b *binaryCodec) IsBinary() bool { return true }

func (b *binaryCodec) Unmarshal(binary []byte, msg any) error {
	pm, ok := msg.(proto.Message)
	if !ok {
		return errNotProto(msg)
	}
	if err := b.unmarshal.Unmarshal(binary, pm); err != nil {
		return fmt.Errorf("unmarshal into %T: %w", pm, err)
	}
	return nil
}

func (b *binaryCodec) Marshal(msg any) ([]byte, error) {
	return b.marshalBinary(nil, msg, false /* stable */)
}

func (b *binaryCodec) MarshalStable(msg any) ([]byte, error) {
	return b.marshalBinary(nil, msg, true /* stable */)
}

func (b *binaryCodec) MarshalAppend(dst []byte, msg any) ([]byte, error) {
	return b.marshalBinary(dst, msg, false /* stable */)
}

func (b *binaryCodec) marshalBinary(dst []byte, msg any, stable bool) ([]byte, error) {
	pm, ok := msg.(proto.Message)
	if !ok {
		return nil, errNotProto(msg)
	}
	if stable {
		return b.stable.MarshalAppend(dst, pm)
	}
	return b.marshal.MarshalAppend(dst, pm)
}

type vtBinaryCodec struct {
	*binaryCodec
}

func newBinaryVTCodec() *vtBinaryCodec {
	return &vtBinaryCodec{newBinaryCodec(proto.MarshalOptions{}, proto.UnmarshalOptions{})}
}

func newBinaryVTCodecWithFallback(other *binaryCodec) *vtBinaryCodec {
	return &vtBinaryCodec{other}
}

func (v *vtBinaryCodec) Unmarshal(binary []byte, msg any) error {
	if vt, ok := msg.(interface{ UnmarshalVT([]byte) error }); ok {
		if err := vt.UnmarshalVT(binary); err != nil {
			return fmt.Errorf("unmarshal into %T: %w", msg, err)
		}
		return nil
	}
	return v.binaryCodec.Unmarshal(binary, msg)
}

func (v *vtBinaryCodec) Marshal(msg any) ([]byte, error) {
	if vt, ok := msg.(interface{ MarshalVT() ([]byte, error) }); ok {
		return vt.MarshalVT()
	}
	return v.binaryCodec.Marshal(msg)
}
